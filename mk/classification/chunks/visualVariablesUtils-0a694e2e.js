import{bt as e,t,x as s}from"../main.js";import{x as n,e as o}from"./Utils-a0a3c935.js";import{a3 as i}from"./enums-c2efc4ce.js";import{o as r}from"./visualVariablesUtils-f8e41de3.js";const l=8388607,a=8388608,u=0,c=1,f=e=>(e&a)>>>23,p=e=>8388607&e,v=e=>1===f(e)?254:255;function m(e){return 1===f(e)}function d(e,t){return((t?a:0)|e)>>>0}function y(e,t=0,s=!1){const n=e[t+3];return e[t+0]*=n,e[t+1]*=n,e[t+2]*=n,s||(e[t+3]*=255),e}function h(e){if(!e)return 0;const{r:t,g:s,b:o,a:i}=e;return n(t*i,s*i,o*i,255*i)}function z(e){if(!e)return 0;const[t,s,o,i]=e;return n(t*(i/255),s*(i/255),o*(i/255),i)}const g=(e,t)=>e&&((...e)=>t.warn("DEBUG:",...e))||(()=>null),S=!1;function b(e,t){if(!e||!t)return e;switch(t){case"radius":case"distance":return 2*e;case"diameter":case"width":return e;case"area":return Math.sqrt(e)}return e}function x(t){return t.map((t=>function(t){return{value:t.value,size:e(t.size)}}(t)))}function E(t){if("string"==typeof t||"number"==typeof t)return e(t);const s=t;return{type:"size",expression:s.expression,stops:x(s.stops)}}const V=e=>{const t=[],n=[],o=x(e),r=o.length;for(let e=0;e<6;e++){const l=o[Math.min(e,r-1)];t.push(l.value),n.push(null==l.size?i:s(l.size))}return{values:new Float32Array(t),sizes:new Float32Array(n)}};function _(e){const t=e&&e.length>0?{}:null,s=t?{}:null;if(!t)return{vvFields:t,vvRanges:s};for(const n of e)if(n.field&&(t[n.type]=n.field),"size"===n.type){s.size||(s.size={});const e=n;switch(r(e)){case o.SIZE_MINMAX_VALUE:s.size.minMaxValue={minDataValue:e.minDataValue,maxDataValue:e.maxDataValue,minSize:E(e.minSize),maxSize:E(e.maxSize)};break;case o.SIZE_SCALE_STOPS:s.size.scaleStops={stops:x(e.stops)};break;case o.SIZE_FIELD_STOPS:if(e.levels){const t={};for(const s in e.levels)t[s]=V(e.levels[s]);s.size.fieldStops={type:"level-dependent",levels:t}}else s.size.fieldStops={type:"static",...V(e.stops)};break;case o.SIZE_UNIT_VALUE:s.size.unitValue={unit:e.valueUnit,valueRepresentation:e.valueRepresentation}}}else if("color"===n.type)s.color=U(n);else if("opacity"===n.type)s.opacity=I(n);else if("rotation"===n.type){const e=n;s.rotation={type:e.rotationType}}return{vvFields:t,vvRanges:s}}function I(e){const t={values:[0,0,0,0,0,0,0,0],opacities:[0,0,0,0,0,0,0,0]};if("string"==typeof e.field){if(!e.stops)return null;{if(e.stops.length>8)return null;const s=e.stops;for(let e=0;e<8;++e){const n=s[Math.min(e,s.length-1)];t.values[e]=n.value,t.opacities[e]=n.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return null;{const s=e.stops&&e.stops.length>=0&&e.stops[0].opacity;for(let e=0;e<8;e++)t.values[e]=1/0,t.opacities[e]=s}}return t}function M(e,t,s){e[4*t+0]=s.r/255,e[4*t+1]=s.g/255,e[4*t+2]=s.b/255,e[4*t+3]=s.a}function U(e){if(t(e))return null;if(e.normalizationField)return null;const s={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};if("string"==typeof e.field){if(!e.stops)return null;{if(e.stops.length>8)return null;s.field=e.field;const t=e.stops;for(let e=0;e<8;++e){const n=t[Math.min(e,t.length-1)];s.values[e]=n.value,M(s.colors,e,n.color)}}}else{if(!(e.stops&&e.stops.length>=0))return null;{const t=e.stops&&e.stops.length>=0&&e.stops[0].color;for(let e=0;e<8;e++)s.values[e]=1/0,M(s.colors,e,t)}}for(let e=0;e<32;e+=4)y(s.colors,e,!0);return s}export{z as a,v as b,c,l as d,f as e,p as f,h as i,S as l,_ as m,g as n,m as p,b as r,d as s,u};
