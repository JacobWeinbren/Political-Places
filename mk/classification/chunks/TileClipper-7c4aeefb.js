import{d as t,c3 as i}from"../main.js";import{M as s,k as e,m as h,p as n}from"./enums-c2efc4ce.js";import{t as x,s as r}from"./Geometry-aca9ebc3.js";import{g as l}from"./GeometryUtils-c54ea35c.js";let y=null,a=null;async function o(){return y||(y=async function(){const s=t("esri-csp-restrictions")?await import("./libtess-asm-5fc0d36c.js").then((t=>t.l)):await import("./libtess-159dace0.js").then((t=>t.l));a=await s.load({locateFile:()=>i("esri/core/libs/libtess/libtess.wasm")})}()),y}function c(t,i){const s=Math.max(t.length,128e3);return a.triangulate(t,i,s)}function u(t,i){return t.x===i.x&&t.y===i.y}function m(t,i){return t.x=i.y,t.y=-i.x,t}function p(t,i){return t.x=-i.y,t.y=i.x,t}function d(t,i){return t.x=i.x,t.y=i.y,t}function f(t,i){return t.x=-i.x,t.y=-i.y,t}function g(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function _(t,i){return t.x*i.y-t.y*i.x}function v(t,i){return t.x*i.x+t.y*i.y}function T(t,i,s,e){return t.x=i.x*s+i.y*e,t.y=i.x*e-i.y*s,t}class w{constructor(t,i,s){this.writeVertex=t,this.writeTriangle=i,this.canUseThinTessellation=s,this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.textureNormalLeft={x:0,y:1},this.textureNormalRight={x:0,y:-1},this.textureNormal={x:void 0,y:void 0},this.joinNormal={x:void 0,y:void 0},this.inner={x:void 0,y:void 0},this.outer={x:void 0,y:void 0},this.roundStart={x:void 0,y:void 0},this.roundEnd={x:void 0,y:void 0},this.startBreak={x:void 0,y:void 0},this.endBreak={x:void 0,y:void 0},this.innerPrev={x:void 0,y:void 0},this.innerNext={x:void 0,y:void 0},this.bevelStart={x:void 0,y:void 0},this.bevelEnd={x:void 0,y:void 0},this.bevelMiddle={x:void 0,y:void 0}}tessellate(t,i){(function(t){if(!t)return;const i=t.length;if(i<=1)return;let s=0;for(let e=1;e<i;e++)u(t[e],t[s])||++s===e||(t[s]=t[e]);t.length=s+1})(t),this.canUseThinTessellation&&i.halfWidth<s&&!i.offset?this._tessellateThin(t,i):this._tessellate(t,i)}_tessellateThin(t,i){if(t.length<2)return;const s=i.wrapDistance||65535;let e=i.initialDistance||0,h=!1,n=t[0].x,x=t[0].y;const r=t.length;for(let i=1;i<r;++i){h&&(h=!1,e=0);let r=t[i].x,l=t[i].y,y=r-n,a=l-x,o=Math.sqrt(y*y+a*a);if(y/=o,a/=o,e+o>s){h=!0;const t=(s-e)/o;o=s-e,r=(1-t)*n+t*r,l=(1-t)*x+t*l,--i}const c=this.writeVertex(n,x,0,0,y,a,a,-y,0,-1,e),u=this.writeVertex(n,x,0,0,y,a,-a,y,0,1,e);e+=o;const m=this.writeVertex(r,l,0,0,y,a,a,-y,0,-1,e),p=this.writeVertex(r,l,0,0,y,a,-a,y,0,1,e);this.writeTriangle(c,u,m),this.writeTriangle(u,m,p),n=r,x=l}}_tessellate(t,i){const s=t[0],n=t[t.length-1],x=u(s,n),r=x?3:2;if(t.length<r)return;const l=i.pixelCoordRatio,y=null!=i.capType?i.capType:e.BUTT,a=null!=i.joinType?i.joinType:h.MITER,o=null!=i.miterLimit?Math.min(i.miterLimit,4):2,c=null!=i.roundLimit?Math.min(i.roundLimit,1.05):1.05,w=null!=i.halfWidth?i.halfWidth:2,R=!!i.textured;let b,M,P=null,V=null;const E=this.prevNormal,N=this.nextNormal;let L=-1,k=-1;const B=this.joinNormal;let D,I;const U=this.textureNormalLeft,S=this.textureNormalRight,j=this.textureNormal;let O=-1,z=-1;const A=i.wrapDistance||65535;let q=i.initialDistance||0;const W=this.writeVertex,G=this.writeTriangle,Q=function(t,i,s,e,h,n){const x=W(b,M,D,I,s,e,t,i,h,n,q);return O>=0&&z>=0&&x>=0&&G(O,z,x),O=z,z=x,x};x&&(P=t[t.length-2],N.x=n.x-P.x,N.y=n.y-P.y,k=g(N),N.x/=k,N.y/=k);let X=!1;for(let i=0;i<t.length;++i){if(X&&(X=!1,q=0),P&&(E.x=-N.x,E.y=-N.y,L=k,q+L>A&&(X=!0)),X){const s=(A-q)/L;L=A-q,P={x:(1-s)*P.x+s*t[i].x,y:(1-s)*P.y+s*t[i].y},--i}else P=t[i];b=P.x,M=P.y;const s=i<=0&&!X,n=i===t.length-1;if(s||(q+=L),V=n?x?t[1]:null:t[i+1],V?(N.x=V.x-b,N.y=V.y-M,k=g(N),N.x/=k,N.y/=k):(N.x=void 0,N.y=void 0),!x){if(s){p(B,N),D=B.x,I=B.y,y===e.SQUARE&&(Q(-N.y-N.x,N.x-N.y,N.x,N.y,0,-1),Q(N.y-N.x,-N.x-N.y,N.x,N.y,0,1)),y===e.ROUND&&(Q(-N.y-N.x,N.x-N.y,N.x,N.y,-1,-1),Q(N.y-N.x,-N.x-N.y,N.x,N.y,-1,1)),y!==e.ROUND&&y!==e.BUTT||(Q(-N.y,N.x,N.x,N.y,0,-1),Q(N.y,-N.x,N.x,N.y,0,1));continue}if(n){m(B,E),D=B.x,I=B.y,y!==e.ROUND&&y!==e.BUTT||(Q(E.y,-E.x,-E.x,-E.y,0,-1),Q(-E.y,E.x,-E.x,-E.y,0,1)),y===e.SQUARE&&(Q(E.y-E.x,-E.x-E.y,-E.x,-E.y,0,-1),Q(-E.y-E.x,E.x-E.y,-E.x,-E.y,0,1)),y===e.ROUND&&(Q(E.y-E.x,-E.x-E.y,-E.x,-E.y,1,-1),Q(-E.y-E.x,E.x-E.y,-E.x,-E.y,1,1));continue}}let r,u,W=-_(E,N);if(Math.abs(W)<.01)v(E,N)>0?(B.x=E.x,B.y=E.y,W=1,r=Number.MAX_VALUE,u=!0):(p(B,N),W=1,r=1,u=!1);else{B.x=(E.x+N.x)/W,B.y=(E.y+N.y)/W,r=g(B);const t=(r-1)*w*l;u=r>4||t>L&&t>k}D=B.x,I=B.y;let G=a;switch(a){case h.BEVEL:r<1.05&&(G=h.MITER);break;case h.ROUND:r<c&&(G=h.MITER);break;case h.MITER:r>o&&(G=h.BEVEL)}switch(G){case h.MITER:if(Q(B.x,B.y,-E.x,-E.y,0,-1),Q(-B.x,-B.y,-E.x,-E.y,0,1),n)break;if(R){const t=X?0:q;O=this.writeVertex(b,M,D,I,N.x,N.y,B.x,B.y,0,-1,t),z=this.writeVertex(b,M,D,I,N.x,N.y,-B.x,-B.y,0,1,t)}break;case h.BEVEL:{const t=W<0;let i,s,e,h;if(t){const t=O;O=z,z=t,i=U,s=S}else i=S,s=U;if(u)e=t?p(this.innerPrev,E):m(this.innerPrev,E),h=t?m(this.innerNext,N):p(this.innerNext,N);else{const i=t?f(this.inner,B):d(this.inner,B);e=i,h=i}const x=t?m(this.bevelStart,E):p(this.bevelStart,E);Q(e.x,e.y,-E.x,-E.y,i.x,i.y);const r=Q(x.x,x.y,-E.x,-E.y,s.x,s.y);if(n)break;const l=t?p(this.bevelEnd,N):m(this.bevelEnd,N);if(u){const t=this.writeVertex(b,M,D,I,-E.x,-E.y,0,0,0,0,q);O=this.writeVertex(b,M,D,I,N.x,N.y,h.x,h.y,i.x,i.y,q),z=this.writeVertex(b,M,D,I,N.x,N.y,l.x,l.y,s.x,s.y,q),this.writeTriangle(r,t,z)}else{if(R){const t=this.bevelMiddle;t.x=(x.x+l.x)/2,t.y=(x.y+l.y)/2,T(j,t,-E.x,-E.y),Q(t.x,t.y,-E.x,-E.y,j.x,j.y),T(j,t,N.x,N.y),O=this.writeVertex(b,M,D,I,N.x,N.y,t.x,t.y,j.x,j.y,q),z=this.writeVertex(b,M,D,I,N.x,N.y,h.x,h.y,i.x,i.y,q)}else{const t=O;O=z,z=t}Q(l.x,l.y,N.x,N.y,s.x,s.y)}if(t){const t=O;O=z,z=t}break}case h.ROUND:{const t=W<0;let i,s;if(t){const t=O;O=z,z=t,i=U,s=S}else i=S,s=U;const e=t?f(this.inner,B):d(this.inner,B);let h,x;u?(h=t?p(this.innerPrev,E):m(this.innerPrev,E),x=t?m(this.innerNext,N):p(this.innerNext,N)):(h=e,x=e);const l=t?m(this.roundStart,E):p(this.roundStart,E),y=t?p(this.roundEnd,N):m(this.roundEnd,N),a=Q(h.x,h.y,-E.x,-E.y,i.x,i.y),o=Q(l.x,l.y,-E.x,-E.y,s.x,s.y);if(n)break;const c=this.writeVertex(b,M,D,I,-E.x,-E.y,0,0,0,0,q);u||this.writeTriangle(O,z,c);const g=f(this.outer,e),_=this.writeVertex(b,M,D,I,N.x,N.y,y.x,y.y,s.x,s.y,q);let w,P;const V=r>2;if(V){let i;r!==Number.MAX_VALUE?(g.x/=r,g.y/=r,i=v(E,g),i=(r*(i*i-1)+1)/i):i=-1,w=t?m(this.startBreak,E):p(this.startBreak,E),w.x+=E.x*i,w.y+=E.y*i,P=t?p(this.endBreak,N):m(this.endBreak,N),P.x+=N.x*i,P.y+=N.y*i}T(j,g,-E.x,-E.y);const L=this.writeVertex(b,M,D,I,-E.x,-E.y,g.x,g.y,j.x,j.y,q);T(j,g,N.x,N.y);const k=R?this.writeVertex(b,M,D,I,N.x,N.y,g.x,g.y,j.x,j.y,q):L,A=c,G=R?this.writeVertex(b,M,D,I,N.x,N.y,0,0,0,0,q):c;let X=-1,C=-1;if(V&&(T(j,w,-E.x,-E.y),X=this.writeVertex(b,M,D,I,-E.x,-E.y,w.x,w.y,j.x,j.y,q),T(j,P,N.x,N.y),C=this.writeVertex(b,M,D,I,N.x,N.y,P.x,P.y,j.x,j.y,q)),R?V?(this.writeTriangle(A,o,X),this.writeTriangle(A,X,L),this.writeTriangle(G,k,C),this.writeTriangle(G,C,_)):(this.writeTriangle(A,o,L),this.writeTriangle(G,k,_)):V?(this.writeTriangle(c,o,X),this.writeTriangle(c,X,C),this.writeTriangle(c,C,_)):(this.writeTriangle(c,o,L),this.writeTriangle(c,k,_)),u?(O=this.writeVertex(b,M,D,I,N.x,N.y,x.x,x.y,i.x,i.y,q),z=_):(O=R?this.writeVertex(b,M,D,I,N.x,N.y,x.x,x.y,i.x,i.y,q):a,this.writeTriangle(O,G,_),z=_),t){const t=O;O=z,z=t}break}}}}}class R{constructor(t,i,s){this.ratio=t,this.x=i,this.y=s}}class b{constructor(t,i,s,e=8,h=8){this.lines=[],this.starts=[],this.validateTessellation=!0,this.pixelRatio=e,this.pixelMargin=h,this.tileSize=n*e,this.dz=t,this.yPos=i,this.xPos=s}setPixelMargin(t){t!==this.pixelMargin&&(this.pixelMargin=t,this.setExtent(this._extent))}setExtent(t){this._extent=t,this.finalRatio=this.tileSize/t*(1<<this.dz);let i=this.pixelRatio*this.pixelMargin;i/=this.finalRatio;const s=t>>this.dz;i>s&&(i=s),this.margin=i,this.xmin=s*this.xPos-i,this.ymin=s*this.yPos-i,this.xmax=this.xmin+s+2*i,this.ymax=this.ymin+s+2*i}reset(t){this.type=t,this.lines=[],this.starts=[],this.line=null,this.start=0}moveTo(t,i){this._pushLine(),this._prevIsIn=this._isIn(t,i),this._moveTo(t,i,this._prevIsIn),this._prevPt=new x(t,i),this._firstPt=new x(t,i),this._dist=0}lineTo(t,i){const s=this._isIn(t,i),e=new x(t,i),h=x.distance(this._prevPt,e);let n,r,l,y,a,o,c,u;if(s)this._prevIsIn?this._lineTo(t,i,!0):(n=this._prevPt,r=e,l=this._intersect(r,n),this.start=this._dist+h*(1-this._r),this._lineTo(l.x,l.y,!0),this._lineTo(r.x,r.y,!0));else if(this._prevIsIn)r=this._prevPt,n=e,l=this._intersect(r,n),this._lineTo(l.x,l.y,!0),this._lineTo(n.x,n.y,!1);else{const t=this._prevPt,i=e;if(t.x<=this.xmin&&i.x<=this.xmin||t.x>=this.xmax&&i.x>=this.xmax||t.y<=this.ymin&&i.y<=this.ymin||t.y>=this.ymax&&i.y>=this.ymax)this._lineTo(i.x,i.y,!1);else{const s=[];if((t.x<this.xmin&&i.x>this.xmin||t.x>this.xmin&&i.x<this.xmin)&&(y=(this.xmin-t.x)/(i.x-t.x),u=t.y+y*(i.y-t.y),u<=this.ymin?o=!1:u>=this.ymax?o=!0:s.push(new R(y,this.xmin,u))),(t.x<this.xmax&&i.x>this.xmax||t.x>this.xmax&&i.x<this.xmax)&&(y=(this.xmax-t.x)/(i.x-t.x),u=t.y+y*(i.y-t.y),u<=this.ymin?o=!1:u>=this.ymax?o=!0:s.push(new R(y,this.xmax,u))),(t.y<this.ymin&&i.y>this.ymin||t.y>this.ymin&&i.y<this.ymin)&&(y=(this.ymin-t.y)/(i.y-t.y),c=t.x+y*(i.x-t.x),c<=this.xmin?a=!1:c>=this.xmax?a=!0:s.push(new R(y,c,this.ymin))),(t.y<this.ymax&&i.y>this.ymax||t.y>this.ymax&&i.y<this.ymax)&&(y=(this.ymax-t.y)/(i.y-t.y),c=t.x+y*(i.x-t.x),c<=this.xmin?a=!1:c>=this.xmax?a=!0:s.push(new R(y,c,this.ymax))),0===s.length)a?o?this._lineTo(this.xmax,this.ymax,!0):this._lineTo(this.xmax,this.ymin,!0):o?this._lineTo(this.xmin,this.ymax,!0):this._lineTo(this.xmin,this.ymin,!0);else if(s.length>1&&s[0].ratio>s[1].ratio)this.start=this._dist+h*s[1].ratio,this._lineTo(s[1].x,s[1].y,!0),this._lineTo(s[0].x,s[0].y,!0);else{this.start=this._dist+h*s[0].ratio;for(let t=0;t<s.length;t++)this._lineTo(s[t].x,s[t].y,!0)}this._lineTo(i.x,i.y,!1)}}this._dist+=h,this._prevIsIn=s,this._prevPt=e}close(){if(this.line.length>2){const t=this._firstPt,i=this._prevPt;t.x===i.x&&t.y===i.y||this.lineTo(t.x,t.y);const s=this.line;let e=s.length;for(;e>=4&&(s[0].x===s[1].x&&s[0].x===s[e-2].x||s[0].y===s[1].y&&s[0].y===s[e-2].y);)s.pop(),s[0].x=s[e-2].x,s[0].y=s[e-2].y,--e}}result(t=!0){return this._pushLine(),0===this.lines.length?null:(this.type===r.Polygon&&t&&V.simplify(this.tileSize,this.margin*this.finalRatio,this.lines),this.lines)}resultWithStarts(){if(this.type!==r.LineString)throw new Error("Only valid for lines");this._pushLine();const t=this.lines,i=t.length;if(0===i)return null;const s=[];for(let e=0;e<i;e++)s.push({line:t[e],start:this.starts[e]||0});return s}_isIn(t,i){return t>=this.xmin&&t<=this.xmax&&i>=this.ymin&&i<=this.ymax}_intersect(t,i){let s,e,h;if(i.x>=this.xmin&&i.x<=this.xmax)e=i.y<=this.ymin?this.ymin:this.ymax,h=(e-t.y)/(i.y-t.y),s=t.x+h*(i.x-t.x);else if(i.y>=this.ymin&&i.y<=this.ymax)s=i.x<=this.xmin?this.xmin:this.xmax,h=(s-t.x)/(i.x-t.x),e=t.y+h*(i.y-t.y);else{e=i.y<=this.ymin?this.ymin:this.ymax,s=i.x<=this.xmin?this.xmin:this.xmax;const n=(s-t.x)/(i.x-t.x),x=(e-t.y)/(i.y-t.y);n<x?(h=n,e=t.y+n*(i.y-t.y)):(h=x,s=t.x+x*(i.x-t.x))}return this._r=h,new x(s,e)}_pushLine(){this.line&&(this.type===r.Point?this.line.length>0&&(this.lines.push(this.line),this.starts.push(this.start)):this.type===r.LineString?this.line.length>1&&(this.lines.push(this.line),this.starts.push(this.start)):this.type===r.Polygon&&this.line.length>3&&(this.lines.push(this.line),this.starts.push(this.start))),this.line=[],this.start=0}_moveTo(t,i,s){this.type!==r.Polygon?s&&(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.push(new x(t,i))):(s||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),i<this.ymin&&(i=this.ymin),i>this.ymax&&(i=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.push(new x(t,i)),this._is_h=!1,this._is_v=!1)}_lineTo(t,i,s){let e,h;if(this.type!==r.Polygon)if(s){if(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line.length>0&&(e=this.line[this.line.length-1],e.equals(t,i)))return;this.line.push(new x(t,i))}else this.line&&this.line.length>0&&this._pushLine();else if(s||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),i<this.ymin&&(i=this.ymin),i>this.ymax&&(i=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),i=Math.round((i-(this.ymin+this.margin))*this.finalRatio),this.line&&this.line.length>0){e=this.line[this.line.length-1];const s=e.x===t,n=e.y===i;if(s&&n)return;this._is_h&&s||this._is_v&&n?(e.x=t,e.y=i,h=this.line[this.line.length-2],h.x===t&&h.y===i?(this.line.pop(),this.line.length<=1?(this._is_h=!1,this._is_v=!1):(h=this.line[this.line.length-2],this._is_h=h.x===t,this._is_v=h.y===i)):(this._is_h=h.x===t,this._is_v=h.y===i)):(this.line.push(new x(t,i)),this._is_h=s,this._is_v=n)}else this.line.push(new x(t,i))}}class M{setExtent(t){this._ratio=4096===t?1:4096/t}get validateTessellation(){return this._ratio<1}reset(t){this.lines=[],this.line=null}moveTo(t,i){this.line&&this.lines.push(this.line),this.line=[];const s=this._ratio;this.line.push(new x(t*s,i*s))}lineTo(t,i){const s=this._ratio;this.line.push(new x(t*s,i*s))}close(){const t=this.line;t&&!t[0].isEqual(t[t.length-1])&&t.push(t[0])}result(){return this.line&&this.lines.push(this.line),0===this.lines.length?null:this.lines}}var P;!function(t){t[t.sideLeft=0]="sideLeft",t[t.sideRight=1]="sideRight",t[t.sideTop=2]="sideTop",t[t.sideBottom=3]="sideBottom"}(P||(P={}));class V{static simplify(t,i,s){if(!s)return;const e=-i,h=t+i,n=-i,x=t+i,r=[],l=[],y=s.length;for(let t=0;t<y;++t){const i=s[t];if(!i||i.length<2)continue;let y,a=i[0];const o=i.length;for(let s=1;s<o;++s)y=i[s],a.x===y.x&&(a.x<=e&&(a.y>y.y?(r.push(t),r.push(s),r.push(P.sideLeft),r.push(-1)):(l.push(t),l.push(s),l.push(P.sideLeft),l.push(-1))),a.x>=h&&(a.y<y.y?(r.push(t),r.push(s),r.push(P.sideRight),r.push(-1)):(l.push(t),l.push(s),l.push(P.sideRight),l.push(-1)))),a.y===y.y&&(a.y<=n&&(a.x<y.x?(r.push(t),r.push(s),r.push(P.sideTop),r.push(-1)):(l.push(t),l.push(s),l.push(P.sideTop),l.push(-1))),a.y>=x&&(a.x>y.x?(r.push(t),r.push(s),r.push(P.sideBottom),r.push(-1)):(l.push(t),l.push(s),l.push(P.sideBottom),l.push(-1)))),a=y}if(0===r.length||0===l.length)return;V.fillParent(s,l,r),V.fillParent(s,r,l);const a=[];V.calcDeltas(a,l,r),V.calcDeltas(a,r,l),V.addDeltas(a,s)}static fillParent(t,i,s){const e=s.length,h=i.length;for(let n=0;n<h;n+=4){const h=i[n],x=i[n+1],r=i[n+2],y=t[h][x-1],a=t[h][x];let o=8092,c=-1;for(let i=0;i<e;i+=4){if(s[i+2]!==r)continue;const e=s[i],h=s[i+1],n=t[e][h-1],x=t[e][h];switch(r){case P.sideLeft:case P.sideRight:if(l(y.y,n.y,x.y)&&l(a.y,n.y,x.y)){const t=Math.abs(x.y-n.y);t<o&&(o=t,c=i)}break;case P.sideTop:case P.sideBottom:if(l(y.x,n.x,x.x)&&l(a.x,n.x,x.x)){const t=Math.abs(x.x-n.x);t<o&&(o=t,c=i)}}}i[n+3]=c}}static calcDeltas(t,i,s){const e=i.length;for(let h=0;h<e;h+=4){const e=[],n=V.calcDelta(h,i,s,e);t.push(i[h]),t.push(i[h+1]),t.push(i[h+2]),t.push(n)}}static calcDelta(t,i,s,e){const h=i[t+3];if(-1===h)return 0;const n=e.length;return n>1&&e[n-2]===h?0:(e.push(h),V.calcDelta(h,s,i,e)+1)}static addDeltas(t,i){const s=t.length;let e=0;for(let i=0;i<s;i+=4){const s=t[i+3];s>e&&(e=s)}for(let h=0;h<s;h+=4){const s=i[t[h]],n=t[h+1],x=e-t[h+3];switch(t[h+2]){case P.sideLeft:s[n-1].x-=x,s[n].x-=x,1===n&&(s[s.length-1].x-=x),n===s.length-1&&(s[0].x-=x);break;case P.sideRight:s[n-1].x+=x,s[n].x+=x,1===n&&(s[s.length-1].x+=x),n===s.length-1&&(s[0].x+=x);break;case P.sideTop:s[n-1].y-=x,s[n].y-=x,1===n&&(s[s.length-1].y-=x),n===s.length-1&&(s[0].y-=x);break;case P.sideBottom:s[n-1].y+=x,s[n].y+=x,1===n&&(s[s.length-1].y+=x),n===s.length-1&&(s[0].y+=x)}}}}export{o as a,w as d,M as l,b as n,c as r};
