import{Z as e,_ as r,a8 as t,e0 as i,cz as s,aB as a,cc as o,a0 as n,c8 as l,d3 as u,aT as p,r as c,dv as y,cb as d,C as f,e1 as m}from"../main.js";import{a as B,i as g,u as h,f as b,d as v,o as P}from"./NAMessage-ce8c1499.js";import{c as R}from"./DirectionsFeatureSet-eca49146.js";import"./GPMessage-a5be115d.js";function A(e){return e.features.map((r=>{const t=p.fromJSON(e.spatialReference),i=o.fromJSON(r);return c(i.geometry)&&(i.geometry.spatialReference=t),i}))}function N(e){return u.fromJSON(e).features.map((e=>e.geometry))}let S=class extends l{constructor(e){super(e),this.directions=null,this.facilities=null,this.incidents=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.routes=null}readFacilities(e){return N(e)}readIncidents(e){return N(e)}readPointBarriers(e,r){return N(r.barriers)}readPolylineBarriers(e){return N(e)}readPolygonBarriers(e){return N(e)}readRoutes(e){return A(e)}};e([r({type:[R]})],S.prototype,"directions",void 0),e([r({type:[t]})],S.prototype,"facilities",void 0),e([i("facilities")],S.prototype,"readFacilities",null),e([r({type:[t]})],S.prototype,"incidents",void 0),e([i("incidents")],S.prototype,"readIncidents",null),e([r({type:[B]})],S.prototype,"messages",void 0),e([r({type:[t]})],S.prototype,"pointBarriers",void 0),e([i("pointBarriers",["barriers"])],S.prototype,"readPointBarriers",null),e([r({type:[s]})],S.prototype,"polylineBarriers",void 0),e([i("polylineBarriers")],S.prototype,"readPolylineBarriers",null),e([r({type:[a]})],S.prototype,"polygonBarriers",void 0),e([i("polygonBarriers")],S.prototype,"readPolygonBarriers",null),e([r({type:[o]})],S.prototype,"routes",void 0),e([i("routes")],S.prototype,"readRoutes",null),S=e([n("esri.rest.support.ClosestFacilitySolveResult")],S);const F=S,j=P({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,directionsTimeAttribute:{name:"directionsTimeAttributeName"},impedanceAttribute:{name:"impedanceAttributeName"},facilities:!0,incidents:!0,outSpatialReference:{name:"outSR",getter:e=>e.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},returnPointBarriers:{name:"returnBarriers"},returnRoutes:{name:"returnCFRoutes"},travelMode:!0});let w=class extends m{constructor(e){super(e),this.url=null}solve(e,r){return async function(e,r,t){const i=[],s=[],a={},o={},n=y(e),{path:l}=n;r.incidents&&r.incidents.features&&g(r.incidents.features,s,"incidents.features",a),r.facilities&&r.facilities.features&&g(r.facilities.features,s,"facilities.features",a),r.pointBarriers&&r.pointBarriers.features&&g(r.pointBarriers.features,s,"pointBarriers.features",a),r.polylineBarriers&&r.polylineBarriers.features&&g(r.polylineBarriers.features,s,"polylineBarriers.features",a),r.polygonBarriers&&r.polygonBarriers.features&&g(r.polygonBarriers.features,s,"polygonBarriers.features",a);const u=await d(s);for(const e in a){const r=a[e];i.push(e),o[e]=u.slice(r[0],r[1])}if(h(o,i)){let e=null;try{e=await b(l,r.apiKey,t)}catch{}e&&!e.hasZ&&v(o,i)}for(const e in o)o[e].forEach(((t,i)=>{r.get(e)[i].geometry=t}));const p={...t,query:{...n.query,...j.toQueryParams(r),f:"json"}},{data:c}=await f(`${l}/solveClosestFacility`,p);return F.fromJSON(c)}(this.url,e,r)}};e([r()],w.prototype,"url",void 0),w=e([n("esri.tasks.ClosestFacilityTask")],w);const C=w;export{C as default};
