import{Z as e,_ as t,a0 as r,c8 as n,e3 as o,e0 as s,bH as i,a8 as f,ch as l}from"../main.js";let a=class extends n{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};e([t()],a.prototype,"affectsPixelSize",null),e([t({json:{write:!0}})],a.prototype,"spatialReference",void 0),a=e([r("esri.layers.support.rasterTransforms.BaseRasterTransform")],a);const p=a;let c=class extends p{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(e){return"point"===(e=e.clone()).type?(e.x>180+this.tolerance&&(e.x-=360),e):(e.xmin>=180-this.tolerance?(e.xmax-=360,e.xmin-=360):e.xmax>180+this.tolerance&&(e.xmin=-180,e.xmax=180),e)}inverseTransform(e){return"point"===(e=e.clone()).type?(e.x<-this.tolerance&&(e.x+=360),e):(e.xmin<-this.tolerance&&(e.xmin+=360,e.xmax+=360),e)}};e([o({GCSShiftXform:"gcs-shift"})],c.prototype,"type",void 0),e([t()],c.prototype,"tolerance",void 0),c=e([r("esri.layers.support.rasterTransforms.GCSShiftTransform")],c);const u=c;let y=class extends p{constructor(){super(...arguments),this.type="identity"}};e([o({IdentityXform:"identity"})],y.prototype,"type",void 0),y=e([r("esri.layers.support.rasterTransforms.IdentityTransform")],y);const h=y;function m(e,t,r){const{x:n,y:o}=t;if(r<2)return{x:e[0]+n*e[2]+o*e[4],y:e[1]+n*e[3]+o*e[5]};if(2===r){const t=n*n,r=o*o,s=n*o;return{x:e[0]+n*e[2]+o*e[4]+t*e[6]+s*e[8]+r*e[10],y:e[1]+n*e[3]+o*e[5]+t*e[7]+s*e[9]+r*e[11]}}const s=n*n,i=o*o,f=n*o,l=s*n,a=s*o,p=n*i,c=o*i;return{x:e[0]+n*e[2]+o*e[4]+s*e[6]+f*e[8]+i*e[10]+l*e[12]+a*e[14]+p*e[16]+c*e[18],y:e[1]+n*e[3]+o*e[5]+s*e[7]+f*e[9]+i*e[11]+l*e[13]+a*e[15]+p*e[17]+c*e[19]}}function x(e,t,r){const{xmin:n,ymin:o,xmax:s,ymax:i,spatialReference:f}=t;let a=[];if(r<2)a.push({x:n,y:i}),a.push({x:s,y:i}),a.push({x:n,y:o}),a.push({x:s,y:o});else{let e=10;for(let t=0;t<e;t++)a.push({x:n,y:o+(i-o)*t/(e-1)}),a.push({x:s,y:o+(i-o)*t/(e-1)});e=8;for(let t=1;t<=e;t++)a.push({x:n+(s-n)*t/e,y:o}),a.push({x:n+(s-n)*t/e,y:i})}a=a.map((t=>m(e,t,r)));const p=a.map((e=>e.x)),c=a.map((e=>e.y));return new l({xmin:Math.min.apply(null,p),xmax:Math.max.apply(null,p),ymin:Math.min.apply(null,c),ymax:Math.max.apply(null,c),spatialReference:f})}let d=class extends p{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,t){const{coeffX:r,coeffY:n}=t;if(null==r||!r.length||null==n||!n.length||r.length!==n.length)return null;const o=[];for(let e=0;e<r.length;e++)o.push(r[e]),o.push(n[e]);return o}writeForwardCoefficients(e,t,r){const n=[],o=[];for(let t=0;t<(null==e?void 0:e.length);t++)t%2==0?n.push(e[t]):o.push(e[t]);t.coeffX=n,t.coeffY=o}get inverseCoefficients(){let e=this._get("inverseCoefficients");const t=this._get("forwardCoefficients");return!e&&t&&this.polynomialOrder<2&&(e=function(e){const[t,r,n,o,s,i]=e,f=n*i-s*o,l=s*o-n*i;return[(s*r-t*i)/f,(n*r-t*o)/l,i/f,o/l,-s/f,-n/l]}(t)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,t){const{inverseCoeffX:r,inverseCoeffY:n}=t;if(null==r||!r.length||null==n||!n.length||r.length!==n.length)return null;const o=[];for(let e=0;e<r.length;e++)o.push(r[e]),o.push(n[e]);return o}writeInverseCoefficients(e,t,r){const n=[],o=[];for(let t=0;t<(null==e?void 0:e.length);t++)t%2==0?n.push(e[t]):o.push(e[t]);t.inverseCoeffX=n,t.inverseCoeffY=o}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const t=m(this.forwardCoefficients,e,this.polynomialOrder);return new f({x:t.x,y:t.y,spatialReference:e.spatialReference})}return x(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const t=m(this.inverseCoefficients,e,this.polynomialOrder);return new f({x:t.x,y:t.y,spatialReference:e.spatialReference})}return x(this.inverseCoefficients,e,this.polynomialOrder)}};e([t({json:{write:!0}})],d.prototype,"polynomialOrder",void 0),e([t()],d.prototype,"forwardCoefficients",void 0),e([s("forwardCoefficients",["coeffX","coeffY"])],d.prototype,"readForwardCoefficients",null),e([i("forwardCoefficients")],d.prototype,"writeForwardCoefficients",null),e([t({json:{write:!0}})],d.prototype,"inverseCoefficients",null),e([s("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],d.prototype,"readInverseCoefficients",null),e([i("inverseCoefficients")],d.prototype,"writeInverseCoefficients",null),e([t()],d.prototype,"affectsPixelSize",null),e([o({PolynomialXform:"polynomial"})],d.prototype,"type",void 0),d=e([r("esri.layers.support.rasterTransforms.PolynomialTransform")],d);const v=d,C={GCSShiftXform:u,IdentityXform:h,PolynomialXform:v},w=Object.keys(C);function g(e){const t=null==e?void 0:e.type;return!e||w.includes(t)}function T(e){if(!(null==e?void 0:e.type))return null;const t=C[null==e?void 0:e.type];if(t){const r=new t;return r.read(e),r}return null}export{u as c,g as e,T as f,v as m};
