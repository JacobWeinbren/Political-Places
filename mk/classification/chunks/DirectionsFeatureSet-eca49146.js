import{Z as e,_ as t,a0 as s,cc as r,ch as o,e0 as n,d3 as a,aT as i,cz as p,a8 as l,g as u}from"../main.js";let m=class extends r{};e([t()],m.prototype,"events",void 0),e([t()],m.prototype,"strings",void 0),m=e([s("esri.rest.support.DirectionsFeature")],m);const c=m;let h=class extends a{constructor(e){super(e),this.extent=null,this.features=null,this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null}readFeatures(e,t){var s;if(!e)return[];const r=null!=(s=t.summary.envelope.spatialReference)?s:t.spatialReference,o=r&&i.fromJSON(r);return e.map((e=>{var t,s;const r=this._decompressGeometry(e.compressedGeometry),n=new p({...r,spatialReference:o}),a=null!=(t=null==(s=e.events)?void 0:s.map((e=>{const{arriveTimeUTC:t,ETA:s,point:{x:r,y:n,z:a},strings:i}=e;return new c({geometry:new l({x:r,y:n,z:a,hasZ:void 0!==a,spatialReference:o}),attributes:{ETA:s,arriveTimeUTC:t},strings:i})})))?t:[];return new c({attributes:e.attributes,events:a,geometry:n,strings:e.strings})}))}get mergedGeometry(){if(!this.features)return null;const e=this.features.map((({geometry:e})=>u(e))),t=this.get("extent.spatialReference");return this._mergePolylinesToSinglePath(e,t)}get strings(){return this.features.map((({strings:e})=>e))}_decompressGeometry(e){let t=0,s=0,r=0,o=0;const n=[];let a,i,p,l,u,m,c,h,y=0,d=0,g=0;if(u=e.match(/((\+|\-)[^\+\-\|]+|\|)/g),u||(u=[]),0===parseInt(u[y],32)){y=2;const e=parseInt(u[y],32);y++,m=parseInt(u[y],32),y++,1&e&&(d=u.indexOf("|")+1,c=parseInt(u[d],32),d++),2&e&&(g=u.indexOf("|",d)+1,h=parseInt(u[g],32),g++)}else m=parseInt(u[y],32),y++;for(;y<u.length&&"|"!==u[y];){a=parseInt(u[y],32)+t,y++,t=a,i=parseInt(u[y],32)+s,y++,s=i;const e=[a/m,i/m];d&&(l=parseInt(u[d],32)+r,d++,r=l,e.push(l/c)),g&&(p=parseInt(u[g],32)+o,g++,o=p,e.push(p/h)),n.push(e)}return{paths:[n],hasZ:d>0,hasM:g>0}}_mergePolylinesToSinglePath(e,t){if(0===e.length)return new p({spatialReference:t});const s=[];for(const t of e)for(const e of t.paths)s.push(...e);const r=[];s.forEach(((e,t)=>{0!==t&&e[0]===s[t-1][0]&&e[1]===s[t-1][1]||r.push(e)}));const{hasM:o,hasZ:n}=e[0];return new p({hasM:o,hasZ:n,paths:[r],spatialReference:t})}};e([t({type:o,json:{read:{source:"summary.envelope"}}})],h.prototype,"extent",void 0),e([t()],h.prototype,"features",void 0),e([n("features")],h.prototype,"readFeatures",null),e([t()],h.prototype,"geometryType",void 0),e([t({readOnly:!0})],h.prototype,"mergedGeometry",null),e([t()],h.prototype,"routeId",void 0),e([t()],h.prototype,"routeName",void 0),e([t({value:null,readOnly:!0})],h.prototype,"strings",null),e([t({json:{read:{source:"summary.totalDriveTime"}}})],h.prototype,"totalDriveTime",void 0),e([t({json:{read:{source:"summary.totalLength"}}})],h.prototype,"totalLength",void 0),e([t({json:{read:{source:"summary.totalTime"}}})],h.prototype,"totalTime",void 0),h=e([s("esri.rest.support.DirectionsFeatureSet")],h);const y=h;export{y as c};
