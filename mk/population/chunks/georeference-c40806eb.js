import{fl as r,dp as t,fu as n,Z as e,_ as o,a0 as a,cg as i,a3 as s,A as l,fv as f,fw as c,fx as u,fy as p,fz as y,fA as g,fB as h,fC as m,fD as A,fE as T,a8 as d,r as F,fF as P,fG as E,fH as M,s as v,fI as R,fJ as _,fK as w,fL as x,fM as C,fN as N,fO as b,fi as O,t as L,fP as j,fQ as z,fR as B,fS as S,fT as V,fU as Y}from"../main.js";import{I,v as G,P as q,e as W,a as U}from"./quat-d8d8c4c4.js";import{e as k,a as D,b as H,c as J,f as K,o as Q}from"./vec33-6bed90a4.js";import{T as Z,i as X}from"./BufferView-dd9dc3c0.js";function $(r=or){return[r[0],r[1],r[2],r[3]]}function rr(t,n,e=$()){return r(e,t),e[3]=n,e}function tr(r,t,e=$()){return I(ar,r,er(r)),I(ir,t,er(t)),G(ar,ir,ar),function(r,t){return r[3]=t,r}(e,n(q(e,ar)))}function nr(r){return r}function er(r){return t(r[3])}const or=[0,0,1,0],ar=W(),ir=W();var sr;$();let lr=sr=class extends i{constructor(r){super(r),this.origin=s(),this.translation=s(),this.rotation=$(),this.scale=l(1,1,1),this.geographic=!0}get localMatrix(){const r=k();return f(r,this.scale),c(r,r,er(this.rotation),this.rotation),u(r,r,this.translation),r}get localMatrixInverse(){return p(k(),this.localMatrix)}applyLocal(r,t){return y(t,r,this.localMatrix)}applyLocalInverse(r,t){return y(t,r,this.localMatrixInverse)}project(r,t){const n=new Float64Array(r.length),e=Z.fromTypedArray(n),o=Z.fromTypedArray(r);if(this.geographic){const r=g(t),a=k();return h(t,this.origin,a,r),m(a,a,this.localMatrix),D(e,o,a),A(n,r,0,n,t,0,n.length/3),n}const{localMatrix:a,origin:i}=this;T(a,H)?J(e,o):D(e,o,a);for(let r=0;r<n.length;r+=3)n[r+0]+=i[0],n[r+1]+=i[1],n[r+2]+=i[2];return n}getOriginPoint(r){const[t,n,e]=this.origin;return new d({x:t,y:n,z:e,spatialReference:r})}equals(r){return F(r)&&this.geographic===r.geographic&&P(this.origin,r.origin)&&E(this.localMatrix,r.localMatrix)}clone(){const r={origin:M(this.origin),translation:M(this.translation),rotation:$(this.rotation),scale:M(this.scale),geographic:this.geographic};return new sr(r)}};e([o({type:[Number],nonNullable:!0,json:{write:!0}})],lr.prototype,"origin",void 0),e([o({type:[Number],nonNullable:!0,json:{write:!0}})],lr.prototype,"translation",void 0),e([o({type:[Number],nonNullable:!0,json:{write:!0}})],lr.prototype,"rotation",void 0),e([o({type:[Number],nonNullable:!0,json:{write:!0}})],lr.prototype,"scale",void 0),e([o({type:Boolean,nonNullable:!0,json:{write:!0}})],lr.prototype,"geographic",void 0),e([o()],lr.prototype,"localMatrix",null),e([o()],lr.prototype,"localMatrixInverse",null),lr=sr=e([a("esri.geometry.support.MeshTransform")],lr);const fr=lr;function cr(r,t){var n;return r.isGeographic||r.isWebMercator&&(null==(n=null==t?void 0:t.geographic)||n)}const ur=v.getLogger("esri.geometry.support.meshUtils.normalProjection");function pr(r,t,n,e,o){return Er(e)?(Pr(vr.TO_PCPF,X.fromTypedArray(r),Z.fromTypedArray(t),Z.fromTypedArray(n),e,X.fromTypedArray(o)),o):(ur.error("Cannot convert spatial reference to PCPF"),o)}function yr(r,t,n,e,o){return Er(e)?(Pr(vr.FROM_PCPF,X.fromTypedArray(r),Z.fromTypedArray(t),Z.fromTypedArray(n),e,X.fromTypedArray(o)),o):(ur.error("Cannot convert to spatial reference from PCPF"),o)}function gr(r,t,n){return A(r,t,0,n,g(t),0,r.length/3),n}function hr(r,t,n){return A(r,g(n),0,t,n,0,r.length/3),t}function mr(r,t,n){if(L(r))return t;const e=Z.fromTypedArray(r),o=Z.fromTypedArray(t);return D(o,e,n),t}function Ar(r,t,n){if(L(r))return t;j(xr,n);const e=X.fromTypedArray(r),o=X.fromTypedArray(t);return K(o,e,xr),z(xr)||Q(o,o),t}function Tr(r,t,n){if(L(r))return t;j(xr,n);const e=X.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),o=X.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT);if(K(o,e,xr),z(xr)||Q(o,o),r!==t)for(let n=3;n<r.length;n+=4)t[n]=r[n];return t}function dr(r,t,n,e,o){if(!Er(e))return ur.error("Cannot convert spatial reference to PCPF"),o;Pr(vr.TO_PCPF,X.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),Z.fromTypedArray(t),Z.fromTypedArray(n),e,X.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT));for(let t=3;t<r.length;t+=4)o[t]=r[t];return o}function Fr(r,t,n,e,o){if(!Er(e))return ur.error("Cannot convert to spatial reference from PCPF"),o;Pr(vr.FROM_PCPF,X.fromTypedArray(r,16),Z.fromTypedArray(t),Z.fromTypedArray(n),e,X.fromTypedArray(o,16));for(let t=3;t<r.length;t+=4)o[t]=r[t];return o}function Pr(r,t,n,e,o,a){if(!t)return;const i=n.count,s=g(o);if(Mr(o))for(let n=0;n<i;n++)e.getVec(n,Rr),t.getVec(n,_r),h(s,Rr,wr,s),x(xr,wr),r===vr.FROM_PCPF&&C(xr,xr),N(_r,_r,xr),a.setVec(n,_r);else for(let o=0;o<i;o++){e.getVec(o,Rr),t.getVec(o,_r),h(s,Rr,wr,s),x(xr,wr);const i=b(n.get(o,1));let l=Math.cos(i);r===vr.TO_PCPF&&(l=1/l),xr[0]*=l,xr[1]*=l,xr[2]*=l,xr[3]*=l,xr[4]*=l,xr[5]*=l,r===vr.FROM_PCPF&&C(xr,xr),N(_r,_r,xr),O(_r,_r),a.setVec(o,_r)}return a}function Er(r){return Mr(r)||function(r){return r.isWebMercator}(r)}function Mr(r){return r.isWGS84||R(r)||_(r)||w(r)}var vr;!function(r){r[r.TO_PCPF=0]="TO_PCPF",r[r.FROM_PCPF=1]="FROM_PCPF"}(vr||(vr={}));const Rr=s(),_r=s(),wr=k(),xr=U();function Cr(r,t,n){return cr(t.spatialReference,n)?function(r,t,n){const e=t.spatialReference,o=Vr(t,n,qr),a=new Float64Array(r.position.length),i=function(r,t,n,e){D(Z.fromTypedArray(e),Z.fromTypedArray(r),t);const o=new Float64Array(r.length);return hr(e,o,n)}(r.position,o,e,a),s=j(Ur,o);return{position:i,normal:jr(i,a,r.normal,s,e),tangent:zr(i,a,r.tangent,s,e)}}(r,t,n):function(r,t,n){const e=new Float64Array(r.position.length),o=r.position,a=t.x,i=t.y,s=t.z||0,{horizontal:l,vertical:f}=Gr(n?n.unit:null,t.spatialReference);for(let r=0;r<o.length;r+=3)e[r+0]=o[r+0]*l+a,e[r+1]=o[r+1]*l+i,e[r+2]=o[r+2]*f+s;return{position:e,normal:r.normal,tangent:r.tangent}}(r,t,n)}function Nr(r,t,n){const{position:e,normal:o,tangent:a}=r;if(L(t))return{position:e,normal:o,tangent:a};const i=t.localMatrix;return Cr({position:mr(e,new Float64Array(e.length),i),normal:F(o)?Ar(o,new Float32Array(o.length),i):null,tangent:F(a)?Tr(a,new Float32Array(a.length),i):null},t.getOriginPoint(n),{geographic:t.geographic})}function br(r,t,n){if(null!=n&&n.useTransform){var e;const{position:o,normal:a,tangent:i}=r;return{vertexAttributes:{position:o,normal:a,tangent:i},transform:new fr({origin:[t.x,t.y,null!=(e=t.z)?e:0],geographic:cr(t.spatialReference,n)})}}return{vertexAttributes:Cr(r,t,n),transform:null}}function Or(r,t,n){return cr(t.spatialReference,n)?Sr(r,t,n):Br(r,t,n)}function Lr(r,t,n,e){if(L(t))return Or(r,n,e);const o=Nr(r,t,n.spatialReference);return n.equals(t.getOriginPoint(n.spatialReference))?Br(o,n,e):cr(n.spatialReference,e)?Sr(o,n,e):Br(o,n,e)}function jr(r,t,n,e,o){if(L(n))return null;const a=new Float32Array(n.length);return K(X.fromTypedArray(a),X.fromTypedArray(n),e),yr(a,r,t,o,a),a}function zr(r,t,n,e,o){if(L(n))return null;const a=new Float32Array(n.length);K(X.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT),X.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),e);for(let r=3;r<a.length;r+=4)a[r]=n[r];return Fr(a,r,t,o,a),a}function Br(r,t,n){const e=new Float64Array(r.position.length),o=r.position,a=t.x,i=t.y,s=t.z||0,{horizontal:l,vertical:f}=Gr(n?n.unit:null,t.spatialReference);for(let r=0;r<o.length;r+=3)e[r+0]=(o[r+0]-a)/l,e[r+1]=(o[r+1]-i)/l,e[r+2]=(o[r+2]-s)/f;return{position:e,normal:r.normal,tangent:r.tangent}}function Sr(r,t,n){const e=t.spatialReference;Vr(t,n,qr);const o=p(Wr,qr),a=new Float64Array(r.position.length),i=function(r,t,n,e){const o=gr(r,t,e),a=Z.fromTypedArray(o),i=new Float64Array(o.length),s=Z.fromTypedArray(i);return D(s,a,n),i}(r.position,e,o,a),s=j(Ur,o);return{position:i,normal:Yr(r.normal,r.position,a,e,s),tangent:Ir(r.tangent,r.position,a,e,s)}}function Vr(r,t,n){h(r.spatialReference,[r.x,r.y,r.z||0],n,g(r.spatialReference));const{horizontal:e,vertical:o}=Gr(t?t.unit:null,r.spatialReference);return B(n,n,[e,e,o]),n}function Yr(r,t,n,e,o){if(L(r))return null;const a=pr(r,t,n,e,new Float32Array(r.length)),i=X.fromTypedArray(a);return K(i,i,o),a}function Ir(r,t,n,e,o){if(L(r))return null;const a=dr(r,t,n,e,new Float32Array(r.length)),i=X.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT);return K(i,i,o),a}function Gr(r,t){if(L(r))return kr;const n=t.isGeographic?1:S(t),e=t.isGeographic?1:V(t),o=Y(1,r,"meters");return{horizontal:o*n,vertical:o*e}}const qr=k(),Wr=k(),Ur=U(),kr={horizontal:1,vertical:1};export{Fr as L,Or as M,hr as O,Lr as P,Nr as _,gr as a,br as b,$ as c,er as d,rr as e,fr as f,yr as h,pr as j,dr as k,nr as l,tr as q,cr as r,Cr as x};
