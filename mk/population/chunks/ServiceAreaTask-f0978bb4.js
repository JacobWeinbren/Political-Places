import{Z as e,_ as r,a8 as t,ed as s,cH as a,aB as i,ck as o,a0 as l,cg as n,eG as p,r as u,bO as y,aT as c,g as f,dE as B,cj as d,C as g,ee as m}from"../main.js";import{a as v,i as P,u as A,f as h,d as S,o as b}from"./NAMessage-a8fd5523.js";import"./GPMessage-65bba7e8.js";function R(e){return e.features.map((r=>{const t=c.fromJSON(e.spatialReference),s=o.fromJSON(r);return f(s.geometry).spatialReference=t,s}))}function N(e){return p(e.features.map((r=>(u(r.geometry)&&(r.geometry.spatialReference=e.spatialReference),y(r.geometry)))))}let j=class extends n{constructor(e){super(e),this.facilities=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.serviceAreaPolylines=null,this.serviceAreaPolygons=null}readFacilities(e){return N(e)}readPointBarriers(e,r){return N(r.barriers)}readPolylineBarriers(e){return N(e)}readPolygonBarriers(e){return N(e)}readIncidents(e,r){return R(r.saPolylines)}readServiceAreaPolygons(e,r){return R(r.saPolygons)}};e([r({type:[t]})],j.prototype,"facilities",void 0),e([s("facilities")],j.prototype,"readFacilities",null),e([r({type:[v]})],j.prototype,"messages",void 0),e([r({type:[t]})],j.prototype,"pointBarriers",void 0),e([s("pointBarriers",["barriers"])],j.prototype,"readPointBarriers",null),e([r({type:[a]})],j.prototype,"polylineBarriers",void 0),e([s("polylineBarriers")],j.prototype,"readPolylineBarriers",null),e([r({type:[i]})],j.prototype,"polygonBarriers",void 0),e([s("polygonBarriers")],j.prototype,"readPolygonBarriers",null),e([r({type:[o]})],j.prototype,"serviceAreaPolylines",void 0),e([s("serviceAreaPolylines",["saPolylines"])],j.prototype,"readIncidents",null),e([r({type:[o]})],j.prototype,"serviceAreaPolygons",void 0),e([s("serviceAreaPolygons",["saPolygons"])],j.prototype,"readServiceAreaPolygons",null),j=e([l("esri.rest.support.ServiceAreaSolveResult")],j);const k=j,w=b({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,defaultBreaks:!0,facilities:!0,outSpatialReference:{name:"outSR",getter:e=>e.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},returnPointBarriers:{name:"returnBarriers"},travelMode:!0});let O=class extends m{constructor(e){super(e),this.url=null}solve(e,r){return async function(e,r,t){const s=[],a=[],i={},o={},l=B(e),{path:n}=l;r.facilities&&r.facilities.features&&P(r.facilities.features,a,"facilities.features",i),r.pointBarriers&&r.pointBarriers.features&&P(r.pointBarriers.features,a,"pointBarriers.features",i),r.polylineBarriers&&r.polylineBarriers.features&&P(r.polylineBarriers.features,a,"polylineBarriers.features",i),r.polygonBarriers&&r.polygonBarriers.features&&P(r.polygonBarriers.features,a,"polygonBarriers.features",i);const p=await d(a);for(const e in i){const r=i[e];s.push(e),o[e]=p.slice(r[0],r[1])}if(A(o,s)){let e=null;try{e=await h(n,r.apiKey,t)}catch{}e&&!e.hasZ&&S(o,s)}for(const e in o)o[e].forEach(((t,s)=>{r.get(e)[s].geometry=t}));const u={...t,query:{...l.query,...w.toQueryParams(r),f:"json"}},{data:y}=await g(`${n}/solveServiceArea`,u);return k.fromJSON(y)}(this.url,e,r)}};e([r()],O.prototype,"url",void 0),O=e([l("esri.tasks.ServiceAreaTask")],O);const x=O;export{x as default};
